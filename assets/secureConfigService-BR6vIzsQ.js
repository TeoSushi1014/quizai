import{l as i,U as n}from"./index-BRvFz_qz.js";class c{constructor(){this.apiKeysCache=new Map,this.cacheExpiry=new Map,this.CACHE_DURATION=5*60*1e3}static getInstance(){return c.instance||(c.instance=new c),c.instance}isCacheValid(e){const a=this.cacheExpiry.get(e);return a?Date.now()<a:!1}async getApiKey(e){var a;try{if(this.isCacheValid(e)){const s=this.apiKeysCache.get(e);if(s)return i.info(`Using cached API key for ${e}`,"SecureConfigService"),s}let r=null,t=null;try{const s=await n.from("api_keys").select("key_value").eq("key_name",e).eq("owner_email",((a=(await n.auth.getUser()).data.user)==null?void 0:a.email)||"").single();r=s.data,t=s.error}catch{i.info(`No personal API key found for ${e}, trying default`,"SecureConfigService")}if(!r||t){i.info(`Falling back to default system API key for ${e}`,"SecureConfigService");const s=await n.from("api_keys").select("key_value").eq("key_name",e).eq("owner_email","default@system").single();r=s.data,t=s.error}return t?(i.error(`Failed to fetch API key: ${e}`,"SecureConfigService",{error:t}),null):r!=null&&r.key_value?(this.apiKeysCache.set(e,r.key_value),this.cacheExpiry.set(e,Date.now()+this.CACHE_DURATION),i.info(`Successfully fetched API key for ${e}`,"SecureConfigService"),r.key_value):(i.warn(`No API key found for ${e}`,"SecureConfigService"),null)}catch(r){return i.error(`Error fetching API key: ${e}`,"SecureConfigService",{},r),null}}async getUserPersonalApiKey(e){var a,r;try{const t=await n.from("api_keys").select("key_value").eq("key_name",e).eq("owner_email",((a=(await n.auth.getUser()).data.user)==null?void 0:a.email)||"").single();return t.error?null:((r=t.data)==null?void 0:r.key_value)||null}catch(t){return i.error(`Error fetching personal API key: ${e}`,"SecureConfigService",{},t),null}}async setApiKey(e,a){var r;try{const{error:t}=await n.from("api_keys").upsert({key_name:e,key_value:a,owner_email:(r=(await n.auth.getUser()).data.user)==null?void 0:r.email});return t?(i.error(`Failed to save API key: ${e}`,"SecureConfigService",{error:t}),!1):(this.apiKeysCache.set(e,a),this.cacheExpiry.set(e,Date.now()+this.CACHE_DURATION),i.info(`Successfully saved API key for ${e}`,"SecureConfigService"),!0)}catch(t){return i.error(`Error saving API key: ${e}`,"SecureConfigService",{},t),!1}}clearCache(){this.apiKeysCache.clear(),this.cacheExpiry.clear(),i.info("API keys cache cleared","SecureConfigService")}async hasApiKey(e){return await this.getApiKey(e)!==null}}const l=c.getInstance();export{l as s};
